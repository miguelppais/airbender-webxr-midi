<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Airbender XR</title>
    <style>
        body { margin: 0; background-color: #050505; color: #eee; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92); z-index: 10; display: flex; flex-direction: column;
            align-items: center; justify-content: center; transition: opacity 0.5s;
        }
        .panel {
            background: #151515; padding: 2rem; border-radius: 16px; border: 1px solid #333;
            max-width: 700px; width: 95%; box-shadow: 0 0 80px rgba(0,210,255,0.15);
            max-height: 95vh; overflow-y: auto;
        }
        h1 { margin: 0 0 0.5rem 0; color: #fff; font-weight: 200; font-size: 1.8rem; letter-spacing: 2px; }
        h2 { margin: 0 0 1.5rem 0; font-size: 0.9rem; color: #00d2ff; text-transform: uppercase; letter-spacing: 1px; }
        
        .section { margin-bottom: 1.5rem; padding-bottom: 1.5rem; border-bottom: 1px solid #333; }
        .section:last-child { border-bottom: none; }
        
        label { display: block; margin-bottom: 0.5rem; font-size: 0.85rem; color: #888; text-transform: uppercase; letter-spacing: 0.5px; }
        select, input[type="number"] {
            width: 100%; padding: 8px; background: #222; border: 1px solid #444;
            color: #fff; border-radius: 4px; font-size: 0.9rem; box-sizing: border-box; transition: 0.2s;
        }
        select:focus, input:focus { outline: none; border-color: #00d2ff; background: #2a2a2a; }

        /* Preset Buttons */
        .preset-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 15px; }
        .preset-btn {
            background: #222; border: 1px solid #444; color: #aaa; padding: 10px;
            border-radius: 6px; cursor: pointer; font-size: 0.8rem; transition: 0.2s; text-align: center;
        }
        .preset-btn:hover { background: #333; color: #fff; }
        .preset-btn.active { background: #00d2ff; color: #000; border-color: #00d2ff; font-weight: bold; }

        /* Mapping Grid */
        .hand-col { display: flex; flex-direction: column; gap: 5px; }
        .hand-header { font-weight: bold; color: #00d2ff; margin-bottom: 5px; font-size: 0.9rem; text-align: center; }
        .map-grid { display: grid; grid-template-columns: 80px 1fr 1fr; gap: 15px; align-items: center; margin-bottom: 8px; background: #1a1a1a; padding: 8px; border-radius: 6px;}
        .dim-label { font-weight: bold; color: #fff; font-size: 0.85rem; }
        
        /* Start Button */
        button#start-btn {
            background: linear-gradient(135deg, #00d2ff 0%, #0078ff 100%);
            color: #fff; font-weight: bold; border: none;
            padding: 16px; border-radius: 8px; cursor: pointer; width: 100%;
            font-size: 1.1rem; letter-spacing: 1px; text-transform: uppercase;
            box-shadow: 0 4px 20px rgba(0,120,255,0.3); transition: transform 0.1s, box-shadow 0.2s;
        }
        button#start-btn:active { transform: scale(0.98); }
        button#start-btn:disabled { background: #333; color: #555; cursor: not-allowed; box-shadow: none; transform: none; }
        
        #status { margin-top: 15px; font-size: 0.8rem; color: #666; text-align: center; }
        .hidden { opacity: 0; pointer-events: none; }
        
        .led { width: 8px; height: 8px; border-radius: 50%; background: #333; margin-right: 10px; display: inline-block; }
        .led.on { background: #00ff00; box-shadow: 0 0 10px #00ff00; }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>

    <div id="overlay">
        <div class="panel">
            <h1>Airbender XR</h1>
            <h2>Dual-Hand Spatial Controller</h2>
            
            <div class="section">
                <label>1. Connect Hardware</label>
                <div style="display:flex; align-items:center; margin-bottom:5px;">
                    <div id="led-out" class="led"></div>
                    <select id="midi-out-select"><option value="">Scanning...</option></select>
                </div>
                <div style="font-size:0.75rem; color:#666;">Select your ROLI Piano to merge data.</div>
            </div>

            <div class="section">
                <label>2. Channel</label>
                <div>
                    <span style="font-size:0.8rem; color:#888;">Hand Control Channel</span>
                    <input type="number" id="midi-channel" value="1" min="1" max="16">
                </div>
            </div>

            <div class="section">
                <label>3. 5D Air Mapping (Left & Right)</label>
                <div class="preset-grid">
                    <button class="preset-btn active" onclick="applyPreset('airwave')">Airwave Defaults</button>
                    <button class="preset-btn" onclick="applyPreset('macros')">Equator Macros</button>
                    <button class="preset-btn" onclick="applyPreset('standard')">Standard CC</button>
                </div>

                <div style="display:grid; grid-template-columns: 80px 1fr 1fr; gap:15px; margin-bottom:5px;">
                    <div></div>
                    <div class="hand-header" style="color:#00d2ff">LEFT HAND (Blue)</div>
                    <div class="hand-header" style="color:#ff3333">RIGHT HAND (Red)</div>
                </div>

                <!-- Raise -->
                <div class="map-grid">
                    <div class="dim-label">RAISE (Y)</div>
                    <input type="number" id="cc-l-y" placeholder="CC">
                    <input type="number" id="cc-r-y" placeholder="CC">
                </div>
                <!-- Glide -->
                <div class="map-grid">
                    <div class="dim-label">GLIDE (X)</div>
                    <input type="number" id="cc-l-x" placeholder="CC">
                    <input type="number" id="cc-r-x" placeholder="CC">
                </div>
                <!-- Slide -->
                <div class="map-grid">
                    <div class="dim-label">SLIDE (Z)</div>
                    <input type="number" id="cc-l-z" placeholder="CC">
                    <input type="number" id="cc-r-z" placeholder="CC">
                </div>
                <!-- Tilt -->
                <div class="map-grid">
                    <div class="dim-label">TILT (Roll)</div>
                    <input type="number" id="cc-l-rot" placeholder="CC">
                    <input type="number" id="cc-r-rot" placeholder="CC">
                </div>
                <!-- Flex -->
                <div class="map-grid">
                    <div class="dim-label">FLEX (Pitch)</div>
                    <input type="number" id="cc-l-flex" placeholder="CC">
                    <input type="number" id="cc-r-flex" placeholder="CC">
                </div>
            </div>

            <button id="start-btn" disabled>Enter Mixed Reality</button>
            <div id="status">Waiting for MIDI...</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

        // --- Config ---
        const CONFIG = {
            smooth: 0.15,
            boxSize: 0.45, 
        };

        // --- State ---
        let scene, camera, renderer;
        let controlBox;
        let cursorL, cursorR; // Dual cursors
        let handL, handR;
        let isGrabbing = false;
        let grabController = null;
        let grabOffset = new THREE.Vector3();
        let boxPlaced = false; 
        
        let midi = { access: null, out: null };
        let ledTimer = null;

        // Tracking history for smoothing
        const handsState = {
            left: { pos: new THREE.Vector3(0.5,0.5,0.5), roll: 0.5, pitch: 0.5, lastCC: {} },
            right: { pos: new THREE.Vector3(0.5,0.5,0.5), roll: 0.5, pitch: 0.5, lastCC: {} }
        };

        // --- UI Refs ---
        const ui = {
            overlay: document.getElementById('overlay'),
            status: document.getElementById('status'),
            selOut: document.getElementById('midi-out-select'),
            btn: document.getElementById('start-btn'),
            ledOut: document.getElementById('led-out'),
            channel: document.getElementById('midi-channel'),
            inputs: {
                l: { y: document.getElementById('cc-l-y'), x: document.getElementById('cc-l-x'), z: document.getElementById('cc-l-z'), rot: document.getElementById('cc-l-rot'), flex: document.getElementById('cc-l-flex') },
                r: { y: document.getElementById('cc-r-y'), x: document.getElementById('cc-r-x'), z: document.getElementById('cc-r-z'), rot: document.getElementById('cc-r-rot'), flex: document.getElementById('cc-r-flex') }
            },
            presets: document.querySelectorAll('.preset-btn')
        };

        init();

        function init() {
            if (navigator.requestMIDIAccess) {
                navigator.requestMIDIAccess({ sysex: false }).then(onMidiSuccess, onMidiFail);
            } else {
                ui.status.innerText = "Browser does not support Web MIDI.";
            }
            window.applyPreset = applyPreset;
            applyPreset('airwave'); // Default
            setupThree();
        }

        function applyPreset(name) {
            ui.presets.forEach(b => b.classList.remove('active'));
            
            if (name === 'airwave') {
                ui.presets[0].classList.add('active');
                // Mimic ROLI Airwave Defaults where known + logical pairs
                setMap('l', 74, 113, 71, 28, 30);  // Raise(Timbre), Glide, Slide(Res), TiltL, FlexL
                setMap('r', 11, 114, 107, 29, 31); // Raise(Exp), Glide2, Slide(Macro1), TiltR, FlexR
            } else if (name === 'macros') {
                ui.presets[1].classList.add('active');
                setMap('l', 107, 109, 111, 113, 114); // ROLI Faders & XY
                setMap('r', 108, 110, 112, 115, 116); // Aux
            } else {
                ui.presets[2].classList.add('active');
                setMap('l', 1, 16, 17, 18, 19);
                setMap('r', 7, 20, 21, 22, 23);
            }
        }

        function setMap(hand, y, x, z, rot, flex) {
            ui.inputs[hand].y.value = y;
            ui.inputs[hand].x.value = x;
            ui.inputs[hand].z.value = z;
            ui.inputs[hand].rot.value = rot;
            ui.inputs[hand].flex.value = flex;
        }

        // --- MIDI ---
        function onMidiSuccess(access) {
            midi.access = access;
            midi.access.onstatechange = refreshMidi;
            refreshMidi();
            ui.btn.disabled = false;
            ui.status.innerText = "System Ready. Connect ROLI via USB/BT.";
        }
        function onMidiFail(err) { ui.status.innerText = "MIDI Error: " + err; }

        function refreshMidi() {
            const oldOut = midi.out ? midi.out.id : null;
            ui.selOut.innerHTML = "";
            const outputs = Array.from(midi.access.outputs.values());
            if (outputs.length === 0) ui.selOut.add(new Option("No Outputs", ""));
            else outputs.forEach(o => {
                const opt = new Option(o.name, o.id);
                ui.selOut.add(opt);
                if (o.id === oldOut) opt.selected = true;
            });
            if (!midi.out && outputs.length > 0) midi.out = outputs[0];
            ui.selOut.onchange = (e) => midi.out = midi.access.outputs.get(e.target.value);
        }

        function flashLed() {
            ui.ledOut.classList.add('on');
            if (ledTimer) clearTimeout(ledTimer);
            ledTimer = setTimeout(() => ui.ledOut.classList.remove('on'), 100);
        }

        function sendMidi(handKey, param, val01) {
            if (!midi.out) return;
            const ch = Math.max(0, Math.min(15, parseInt(ui.channel.value) - 1));
            const ccInput = ui.inputs[handKey][param];
            if (!ccInput || !ccInput.value) return; // Parameter disabled/empty

            const ccNum = parseInt(ccInput.value);
            const val7 = Math.floor(Math.min(127, Math.max(0, val01 * 127)));
            
            // Check dedupe
            if (handsState[handKey === 'l' ? 'left' : 'right'].lastCC[param] === val7) return;
            handsState[handKey === 'l' ? 'left' : 'right'].lastCC[param] = val7;

            midi.out.send([0xB0 + ch, ccNum, val7]);
            flashLed();
        }

        // --- 3D ---
        function setupThree() {
            const container = document.createElement('div');
            document.body.appendChild(container);
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 10);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            const arBtn = ARButton.createButton(renderer, { 
                requiredFeatures: ['hand-tracking'], 
                optionalFeatures: ['dom-overlay'], 
                domOverlay: { root: document.body }
            });
            arBtn.addEventListener('click', () => ui.overlay.classList.add('hidden'));
            document.body.appendChild(arBtn);

            scene.add(new THREE.HemisphereLight(0x606060, 0x404040));
            const dl = new THREE.DirectionalLight(0xffffff);
            dl.position.set(1, 1, 1);
            scene.add(dl);

            // Hands
            const handFactory = new XRHandModelFactory();
            [0,1].forEach(i => {
                const c = renderer.xr.getController(i);
                c.addEventListener('selectstart', onGrabStart);
                c.addEventListener('selectend', onGrabEnd);
                scene.add(c);
                const h = renderer.xr.getHand(i);
                h.add(handFactory.createHandModel(h));
                scene.add(h);
                if(i===0) handL = h; else handR = h; // Assuming 0=Left 1=Right usually, but we check handedness in loop
            });

            createSceneObjects();
            renderer.setAnimationLoop(loop);
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createSceneObjects() {
            const geo = new THREE.BoxGeometry(CONFIG.boxSize, CONFIG.boxSize, CONFIG.boxSize);
            const mat = new THREE.LineBasicMaterial({ color: 0x00d2ff });
            controlBox = new THREE.LineSegments(new THREE.EdgesGeometry(geo), mat);
            controlBox.position.set(0, 0, -2);
            scene.add(controlBox);
            controlBox.add(new THREE.AxesHelper(0.1));
            
            // Left Cursor (Blue)
            cursorL = new THREE.Mesh(
                new THREE.SphereGeometry(0.015, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0x00d2ff })
            );
            controlBox.add(cursorL);

            // Right Cursor (Red)
            cursorR = new THREE.Mesh(
                new THREE.SphereGeometry(0.015, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xff3333 })
            );
            controlBox.add(cursorR);
        }

        function onGrabStart(e) {
            if (isGrabbing) return;
            const p = new THREE.Vector3();
            controlBox.getWorldPosition(p);
            if (e.target.position.distanceTo(p) < CONFIG.boxSize) {
                isGrabbing = true;
                grabController = e.target;
                grabOffset.copy(controlBox.position).sub(grabController.position);
            }
        }

        function onGrabEnd(e) {
            if (isGrabbing && e.target === grabController) {
                isGrabbing = false;
                grabController = null;
            }
        }

        function processHand(handObj, handState, cursor, handKey) {
            if (!handObj || !handObj.visible || !handObj.joints['index-finger-tip']) {
                cursor.visible = false;
                return;
            }
            cursor.visible = true;

            const joint = handObj.joints['index-finger-tip'];
            const wrist = handObj.joints['wrist'];
            
            // 1. Position Tracking (Raise, Glide, Slide)
            const wp = new THREE.Vector3();
            joint.getWorldPosition(wp);
            const lp = controlBox.worldToLocal(wp.clone());
            const sz = CONFIG.boxSize;
            
            let x = (lp.x + sz/2) / sz; // Glide
            let y = (lp.y + sz/2) / sz; // Raise
            let z = (lp.z + sz/2) / sz; // Slide

            // 2. Rotation Tracking (Tilt, Flex)
            // Calculate Roll (Tilt) - approximate by wrist rotation relative to box
            const q = new THREE.Quaternion();
            wrist.getWorldQuaternion(q);
            // Convert to local box space
            q.premultiply(controlBox.quaternion.clone().invert());
            const euler = new THREE.Euler().setFromQuaternion(q, 'YXZ');
            
            // Roll (Z rotation): Center at 0 (-PI to PI). Map -45deg to +45deg to 0-1
            let roll = (euler.z + (Math.PI/4)) / (Math.PI/2);
            // Pitch (X rotation): Flex
            let pitch = (euler.x + (Math.PI/4)) / (Math.PI/2);

            // Clamp all
            const clamp = (v) => Math.max(0, Math.min(1, v));
            x = clamp(x); y = clamp(y); z = clamp(z);
            roll = clamp(roll); pitch = clamp(pitch);

            // Smooth
            handState.pos.lerp(new THREE.Vector3(x,y,z), CONFIG.smooth);
            handState.roll += (roll - handState.roll) * CONFIG.smooth;
            handState.pitch += (pitch - handState.pitch) * CONFIG.smooth;

            // Visual
            cursor.position.set(
                (handState.pos.x * sz) - sz/2,
                (handState.pos.y * sz) - sz/2,
                (handState.pos.z * sz) - sz/2
            );

            // Send MIDI if inside box
            const active = (x>0 && x<1 && y>0 && y<1 && z>0 && z<1);
            if (active) {
                sendMidi(handKey, 'y', handState.pos.y);    // Raise
                sendMidi(handKey, 'x', handState.pos.x);    // Glide
                sendMidi(handKey, 'z', handState.pos.z);    // Slide
                sendMidi(handKey, 'rot', handState.roll);   // Tilt
                sendMidi(handKey, 'flex', handState.pitch); // Flex
            }
        }

        function loop() {
            // Placement Logic
            if (renderer.xr.isPresenting && !boxPlaced) {
                const camPos = new THREE.Vector3();
                camera.getWorldPosition(camPos);
                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);
                dir.y = 0; dir.normalize();
                const spawn = new THREE.Vector3().copy(camPos).add(dir.multiplyScalar(0.5));
                spawn.y -= 0.1;
                controlBox.position.copy(spawn);
                controlBox.rotation.set(0, 0, 0);
                const target = new THREE.Vector3(camPos.x, spawn.y, camPos.z);
                controlBox.lookAt(target);
                boxPlaced = true;
            }

            // Grabbing Logic
            if (isGrabbing && grabController) {
                controlBox.position.copy(grabController.position).add(grabOffset);
                const camPos = new THREE.Vector3();
                camera.getWorldPosition(camPos);
                const target = new THREE.Vector3(camPos.x, controlBox.position.y, camPos.z);
                controlBox.lookAt(target);
            }

            // Dual Hand Logic
            // Identify Left vs Right based on XRInputSource.handedness
            // handL/handR are just slot 0/1. We need to check their props.
            let realLeft = null, realRight = null;
            
            [handL, handR].forEach(h => {
                if (h && h.visible && h.inputSource) {
                    if (h.inputSource.handedness === 'left') realLeft = h;
                    if (h.inputSource.handedness === 'right') realRight = h;
                }
            });

            processHand(realLeft, handsState.left, cursorL, 'l');
            processHand(realRight, handsState.right, cursorR, 'r');

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
